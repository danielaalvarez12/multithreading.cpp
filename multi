
#include <iostream>
#include <thread>
#include <vector>
#include <mutex>
#include <atomic>
#include <cstdlib>
#include <ctime>
#include <Color.Dlg>
#include "../../../../Downloads/raylib.h"

const int GRID_WIDTH = 80;
const int GRID_HEIGHT = 60;
const int CELL_SIZE = 10;

struct Cell {
    std::atomic<int> owner;   // which thread "owns" the cell
};

std::vector<Cell> grid(GRID_WIDTH* GRID_HEIGHT);

// Mutex for drawing to avoid tearing
std::mutex drawMutex;

// Thread properties
struct ThreadData {
    int id;
    Color color;
};

Color threadColors[] = {
    {255, 0, 0, 255},       // RED
    {0, 121, 241, 255},     // BLUE
    {0, 228, 48, 255},      // GREEN
    {253, 249, 0, 255},     // YELLOW
    {255, 255, 255, 255},   // WHITE
    {0, 0, 0, 255}          // BLACK
};



// cyclic dominance: id beats (id-1)
bool Dominates(int attacker, int defender) {
    if (attacker == defender) return true;
    return ((attacker + 1) % 4) == defender;  // Red beats Yellow, Blue beats Red, etc.
}

void ThreadWorker(ThreadData data) {
    while (true) {
        int x = rand() % GRID_WIDTH;
        int y = rand() % GRID_HEIGHT;
        int index = y * GRID_WIDTH + x;

        int currentOwner = grid[index].owner.load();

        // Interaction rule
        if (Dominates(data.id, currentOwner)) {
            grid[index].owner.store(data.id);
        }

        std::this_thread::sleep_for(std::chrono::milliseconds(2));
    }
}

int main() {
    srand(time(NULL));

    // Initialize grid owners
    for (auto& cell : grid) {
        cell.owner.store(0);
    }

    // Start Raylib
    InitWindow(GRID_WIDTH * CELL_SIZE, GRID_HEIGHT * CELL_SIZE, "Multithreading Drawing");
    SetTargetFPS(60);

    // Create worker threads
    std::vector<std::thread> workers;
    for (int i = 0; i < 4; i++) {
        ThreadData data{ i, threadColors[i] };
        workers.emplace_back(ThreadWorker, data);
    }

    // Main Draw Loop
    while (!WindowShouldClose()) {
        BeginDrawing();
        ClearBackground(BLACK);

        // Draw the grid based on thread ownership
        for (int y = 0; y < GRID_HEIGHT; y++) {
            for (int x = 0; x < GRID_WIDTH; x++) {
                int owner = grid[y * GRID_WIDTH + x].owner.load();
                DrawRectangle(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE, threadColors[owner]);
            }
        }

        EndDrawing();
 
}
